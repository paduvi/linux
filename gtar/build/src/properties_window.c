/* properties_window.c generated by valac 0.30.0, the Vala compiler
 * generated from properties_window.vala, do not modify */

/* Copyright 2015 taprosoft
*
* This file is part of Gtar.
*
* Gtar is free software: you can redistribute it
* and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation, either version 3 of the
* License, or (at your option) any later version.
*
* Gtar is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
* Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with Gtar. If not, see http://www.gnu.org/licenses/.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <stdio.h>


#define TYPE_PROPERTIES_WINDOW (properties_window_get_type ())
#define PROPERTIES_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTIES_WINDOW, PropertiesWindow))
#define PROPERTIES_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTIES_WINDOW, PropertiesWindowClass))
#define IS_PROPERTIES_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTIES_WINDOW))
#define IS_PROPERTIES_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTIES_WINDOW))
#define PROPERTIES_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTIES_WINDOW, PropertiesWindowClass))

typedef struct _PropertiesWindow PropertiesWindow;
typedef struct _PropertiesWindowClass PropertiesWindowClass;
typedef struct _PropertiesWindowPrivate PropertiesWindowPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

struct _PropertiesWindow {
	GtkWindow parent_instance;
	PropertiesWindowPrivate * priv;
};

struct _PropertiesWindowClass {
	GtkWindowClass parent_class;
};


static gpointer properties_window_parent_class = NULL;
extern gint file_counter;

GType properties_window_get_type (void) G_GNUC_CONST;
enum  {
	PROPERTIES_WINDOW_DUMMY_PROPERTY
};
PropertiesWindow* properties_window_new (const gchar* file_name);
PropertiesWindow* properties_window_construct (GType object_type, const gchar* file_name);
gchar* pretty_size (const gchar* file_size);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


PropertiesWindow* properties_window_construct (GType object_type, const gchar* file_name) {
	PropertiesWindow * self = NULL;
	GFile* file = NULL;
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp2_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	GtkTable* vbox = NULL;
	GObject* _tmp53_ = NULL;
	GtkTable* _tmp54_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (file_name != NULL, NULL);
	self = (PropertiesWindow*) g_object_new (object_type, NULL);
	_tmp0_ = file_name;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	file = _tmp1_;
	_tmp2_ = gtk_builder_new ();
	builder = _tmp2_;
	{
		gtk_builder_add_from_file (builder, "ui/properties.ui", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch27_g_error;
		}
	}
	goto __finally27;
	__catch27_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e->message;
		g_error ("properties_window.vala:32: Unable to load file: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally27:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (builder);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		GdkPixbuf* _tmp4_ = NULL;
		GdkPixbuf* _tmp5_ = NULL;
		_tmp5_ = gdk_pixbuf_new_from_file ("tar.ico", &_inner_error_);
		_tmp4_ = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch28_g_error;
		}
		gtk_window_set_icon ((GtkWindow*) self, _tmp4_);
		_g_object_unref0 (_tmp4_);
	}
	goto __finally28;
	__catch28_g_error:
	{
		GError* e = NULL;
		FILE* _tmp6_ = NULL;
		GError* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = stderr;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		fprintf (_tmp6_, "Could not load application icon: %s\n", _tmp8_);
		_g_error_free0 (e);
	}
	__finally28:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (builder);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp9_ = file_name;
	_tmp10_ = g_strconcat (_tmp9_, " Properties", NULL);
	_tmp11_ = _tmp10_;
	gtk_window_set_title ((GtkWindow*) self, _tmp11_);
	_g_free0 (_tmp11_);
	g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER, NULL);
	{
		GFileInfo* info = NULL;
		GFileInfo* _tmp12_ = NULL;
		GtkLabel* p_name = NULL;
		GObject* _tmp13_ = NULL;
		GtkLabel* _tmp14_ = NULL;
		GtkLabel* p_path = NULL;
		GObject* _tmp15_ = NULL;
		GtkLabel* _tmp16_ = NULL;
		GtkLabel* p_type = NULL;
		GObject* _tmp17_ = NULL;
		GtkLabel* _tmp18_ = NULL;
		GtkLabel* p_att = NULL;
		GObject* _tmp19_ = NULL;
		GtkLabel* _tmp20_ = NULL;
		GtkLabel* p_size = NULL;
		GObject* _tmp21_ = NULL;
		GtkLabel* _tmp22_ = NULL;
		GtkLabel* p_files = NULL;
		GObject* _tmp23_ = NULL;
		GtkLabel* _tmp24_ = NULL;
		GtkLabel* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		GtkLabel* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_ = NULL;
		GtkLabel* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		GtkLabel* _tmp32_ = NULL;
		gint64 _tmp33_ = 0LL;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		GtkLabel* _tmp38_ = NULL;
		GTimeVal _tmp39_ = {0};
		GDateTime* _tmp40_ = NULL;
		GDateTime* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_ = NULL;
		GtkLabel* _tmp44_ = NULL;
		gint _tmp45_ = 0;
		gchar* _tmp46_ = NULL;
		gchar* _tmp47_ = NULL;
		_tmp12_ = g_file_query_info (file, "*", 0, NULL, &_inner_error_);
		info = _tmp12_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch29_g_error;
		}
		_tmp13_ = gtk_builder_get_object (builder, "p_name_label");
		_tmp14_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp13_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp13_) : NULL);
		p_name = _tmp14_;
		_tmp15_ = gtk_builder_get_object (builder, "p_path_label");
		_tmp16_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp15_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp15_) : NULL);
		p_path = _tmp16_;
		_tmp17_ = gtk_builder_get_object (builder, "p_mime_type_label");
		_tmp18_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp17_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp17_) : NULL);
		p_type = _tmp18_;
		_tmp19_ = gtk_builder_get_object (builder, "p_att_label");
		_tmp20_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp19_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp19_) : NULL);
		p_att = _tmp20_;
		_tmp21_ = gtk_builder_get_object (builder, "p_size_label");
		_tmp22_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp21_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp21_) : NULL);
		p_size = _tmp22_;
		_tmp23_ = gtk_builder_get_object (builder, "p_files_label");
		_tmp24_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp23_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp23_) : NULL);
		p_files = _tmp24_;
		_tmp25_ = p_name;
		_tmp26_ = g_file_info_get_name (info);
		gtk_label_set_label (_tmp25_, _tmp26_);
		_tmp27_ = p_path;
		_tmp28_ = g_file_get_path (file);
		_tmp29_ = _tmp28_;
		gtk_label_set_label (_tmp27_, _tmp29_);
		_g_free0 (_tmp29_);
		_tmp30_ = p_type;
		_tmp31_ = g_file_info_get_content_type (info);
		gtk_label_set_label (_tmp30_, _tmp31_);
		_tmp32_ = p_size;
		_tmp33_ = g_file_info_get_size (info);
		_tmp34_ = g_strdup_printf ("%" G_GINT64_FORMAT, _tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = pretty_size (_tmp35_);
		_tmp37_ = _tmp36_;
		gtk_label_set_label (_tmp32_, _tmp37_);
		_g_free0 (_tmp37_);
		_g_free0 (_tmp35_);
		_tmp38_ = p_att;
		g_file_info_get_modification_time (info, &_tmp39_);
		_tmp40_ = g_date_time_new_from_timeval_utc (&_tmp39_);
		_tmp41_ = _tmp40_;
		_tmp42_ = g_date_time_format (_tmp41_, "%Y-%m-%d %R");
		_tmp43_ = _tmp42_;
		gtk_label_set_label (_tmp38_, _tmp43_);
		_g_free0 (_tmp43_);
		_g_date_time_unref0 (_tmp41_);
		_tmp44_ = p_files;
		_tmp45_ = file_counter;
		_tmp46_ = g_strdup_printf ("%i", _tmp45_);
		_tmp47_ = _tmp46_;
		gtk_label_set_label (_tmp44_, _tmp47_);
		_g_free0 (_tmp47_);
		_g_object_unref0 (p_files);
		_g_object_unref0 (p_size);
		_g_object_unref0 (p_att);
		_g_object_unref0 (p_type);
		_g_object_unref0 (p_path);
		_g_object_unref0 (p_name);
		_g_object_unref0 (info);
	}
	goto __finally29;
	__catch29_g_error:
	{
		GError* e = NULL;
		FILE* _tmp48_ = NULL;
		GError* _tmp49_ = NULL;
		const gchar* _tmp50_ = NULL;
		gchar* _tmp51_ = NULL;
		gchar* _tmp52_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp48_ = stderr;
		_tmp49_ = e;
		_tmp50_ = _tmp49_->message;
		_tmp51_ = g_strconcat ("Error querying file info: ", _tmp50_, NULL);
		_tmp52_ = _tmp51_;
		fprintf (_tmp48_, "%s", _tmp52_);
		_g_free0 (_tmp52_);
		_g_error_free0 (e);
	}
	__finally29:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (builder);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp53_ = gtk_builder_get_object (builder, "prefs_table");
	_tmp54_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp53_, gtk_table_get_type ()) ? ((GtkTable*) _tmp53_) : NULL);
	vbox = _tmp54_;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) vbox);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (vbox);
	_g_object_unref0 (builder);
	_g_object_unref0 (file);
	return self;
}


PropertiesWindow* properties_window_new (const gchar* file_name) {
	return properties_window_construct (TYPE_PROPERTIES_WINDOW, file_name);
}


static void properties_window_class_init (PropertiesWindowClass * klass) {
	properties_window_parent_class = g_type_class_peek_parent (klass);
}


static void properties_window_instance_init (PropertiesWindow * self) {
}


GType properties_window_get_type (void) {
	static volatile gsize properties_window_type_id__volatile = 0;
	if (g_once_init_enter (&properties_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropertiesWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) properties_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropertiesWindow), 0, (GInstanceInitFunc) properties_window_instance_init, NULL };
		GType properties_window_type_id;
		properties_window_type_id = g_type_register_static (gtk_window_get_type (), "PropertiesWindow", &g_define_type_info, 0);
		g_once_init_leave (&properties_window_type_id__volatile, properties_window_type_id);
	}
	return properties_window_type_id__volatile;
}



